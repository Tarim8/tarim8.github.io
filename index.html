<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>index - Tarim GitHub Repositories</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="date" content="" />
  <link rel="stylesheet" href="css/main.css" type="text/css" />
</head>
<body>
<h1 class="title">Tarim GitHub Repositories</h1>
<div id="utilities"
><h2
  >Utilities</h2
  ><div id="poll-linux-raspberry-pi-c"
  ><h3
    ><a href="https://github.com/tarim8/poll"
      >Poll</a
      > <img src="images/tux.png" alt="Linux"
       /> <a href="http://www.raspberrypi.org"
      ><img src="images/pi.png" alt="Raspberry Pi"
	 /></a
      > <img src="images/cpp.png" title="C++" alt="C++"
       /></h3
    ><p
    >A Linux user command to monitor GPIO pins. Sends the contents of a special file (with optional text) to stdout. Useful for feeding changes in the state of switches or other hardware into your Python, Node JS, C++, AWK or whatever programming language floats your boat. Useful for the Raspberry Pi and other embedded Linux systems that use the /sys/class/gpio style files. GPIO pins can be set up with Gordon Hendersen's gpio control system in his excellent <a href="http://wiringpi.com/"
      >Wiring Pi</a
      > project.</p
    ><div id="example"
    ><h4
      >Example</h4
      ><pre
      ><code
	>poll --debounce 20 --unique +&quot;EncA %l\n&quot; /sys/class/gpio/gpio23/value +&quot;EncB %l\n&quot; /sys/class/gpio/gpio24/value
</code
	></pre
      ><p
      >gives nice clean debounced values from a couple of switches attached to GPIO pins 23 and 24.</p
      ><hr
       /></div
    ></div
  ><div id="session-raspberry-pi-linux-bash"
  ><h3
    ><a href="https://github.com/tarim8/session"
      >Session</a
      > <a href="http://www.raspberrypi.org"
      ><img src="images/pi.png" alt="Raspberry Pi"
	 /></a
      > <img src="images/tux.png" alt="Linux"
       /> <img src="images/bash.png" alt="Bash"
       /></h3
    ><p
    >A Bash script to launch commands with their own process group id. This allows them to be terminated cleanly. A kind of lightweight daemon control.</p
    ><div id="example-1"
    ><h4
      >Example</h4
      ><p
      >omxplayer on the Raspberry Pi will create a subprocess to do the main work. So:</p
      ><pre
      ><code
	>session /tmp/omx.pgid omxplayer video.mp4
</code
	></pre
      ><p
      >allows the video to be terminated cleanly by:</p
      ><pre
      ><code
	>session -k /tmp/omx.pgid
</code
	></pre
      ><hr
       /></div
    ></div
  ><div id="connected-linux-bash"
  ><h3
    ><a href="https://github.com/tarim8/connected"
      >Connected</a
      > <img src="images/tux.png" alt="Linux"
       /> <img src="images/bash.png" alt="Bash"
       /></h3
    ><p
    >Connect to line based services like computer emulators (multics) or games (like adventure, or mud) with Bash command line editing and history.</p
    ><div id="example-2"
    ><h4
      >Example</h4
      ><pre
      ><code
	>connected telnet sve-multics.duckdns.org 6180
</code
	></pre
      ><p
      >Connect to SVE's Multics emulator</p
      ><hr
       /></div
    ></div
  ><div id="sherver-linux-bash"
  ><h3
    ><a href="https://github.com/tarim8/sherver"
      >Sherver</a
      > <img src="images/tux.png" alt="Linux"
       /> <img src="images/bash.png" alt="Bash"
       /></h3
    ><p
    >A lightweight, bash script, CGI compatible web server</p
    ><div id="example-3"
    ><h4
      >Example</h4
      ><pre
      ><code
	>sherver 8081 /srv/root --virtual-host default.com --cgi-bin &quot;&quot; --index-page dirindex --remote
</code
	></pre
      ><p
      >Runs a web server on port 8081 with root of /srv/root/example.com for a request of http://example.com:8081/ Any executable files within the tree will be run as a CGI. Asking for a directory will serve a file listing. REMOTE_PORT and REMOTE_ADDR will be set for CGI scripts.</p
      ><hr
       /></div
    ></div
  ><div id="anyonein-php"
  ><h3
    ><a href="https://github.com/tarim8/anyonein"
      >Anyonein</a
      > <img src="images/php.png" alt="PHP"
       /></h3
    ><p
    >Anyonein is designed to report how long ago various sensors were last activated.</p
    ><p
    >Intended for use in communal spaces, like Hackspaces, where it's handy for people to be able to see if any one is in, or when they were last in.</p
    ><p
    >Anyonein simply logs the time a sensor was last activated through an HTTP interface. It doesn't do anything fancy like processing sensor data which should be done locally by the sensor and its controller.</p
    ><div id="example-4"
    ><h4
      >Example</h4
      ><pre
      ><code
	>http://example.com/anyonein/
</code
	></pre
      ><p
      >will display the current state of the sensors and refresh the page every two minutes.</p
      ><pre
      ><code
	>http://example.com/anyonein/?sensor=light&amp;format=json&amp;show=display
</code
	></pre
      ><p
      >will update the light sensor and return the sensor status as a json object.</p
      ><hr
       /></div
    ></div
  ><div id="waiter-arduino-c"
  ><h3
    ><a href="https://github.com/tarim8/Waiter"
      >Waiter</a
      > <img src="images/arduino.png" alt="Arduino"
       /> <img src="images/cpp.png" alt="C++"
       /></h3
    ><p
    >A class for Arduino to make it easier to wait for an amount of time without going blocked (kind of essential on a single threaded device like an Arduino).</p
    ><div id="example-5"
    ><h4
      >Example</h4
      ><pre
      ><code
	>Waiter timer;
const unsigned int DELAY = 1000;

void function poll() {
    if( timer.wait( DELAY ) ) {
        digitalWrite( LED, !digitalRead( LED ) );
    }
}
</code
	></pre
      ><p
      >Creates a poll() routine which can be continually called (and not block) to flash an LED.</p
      ><hr
       /></div
    ></div
  ></div
><div id="projects"
><h2
  >Projects</h2
  ><div id="totems-arduino-http-c"
  ><h3
    ><a href="https://github.com/tarim8/totems"
      >Totems</a
      > <img src="images/arduino.png" alt="Arduino"
       /> <img src="images/http.png" alt="HTTP"
       /> <img src="images/cpp.png" alt="C++"
       /></h3
    ><p
    >Wicker dolls carried by the audience in <a href="http://www.raucous.org.uk/"
      >Raucous</a
      > Stick House production had their own heartbeat and could become cold during the production.</p
    ><p
    >The dolls contained small Arduino's (Leosticks), a remote control FM receiver, vibration motor and a Peltier heat exchanger. Control is via an Arduino connected to an FM transmitter running a very rudimentary HTTP server which reads a submitted form. In this case the Arduino was connected to a laptop but could equally well have a WiFi shield.</p
    ><div id="notes"
    ><h4
      >Notes</h4
      ><p
      >The vibration motor works well as a heartbeat. The HTTP control system is effective and could easily be connected to other control systems.</p
      ><p
      >The FM signalling worked reasonably but may have range problems in certain venues. It is probably worth replacing this with a Zigbee mesh-net system even though this would take up slightly more space in the dolls.</p
      ><p
      >The Peltier's don't go cold enough for the audience members to notice. Trying to scale them up would involve too many power and heat dissipation problems to be practical.</p
      ><hr
       /></div
    ></div
  ></div
>
</body>
</html>

